// Function to deduct Luck points
async function findAndDeductLuck() {
  const chatMessages = game.messages.contents;
  let luckValue = null;

  for (let message of chatMessages.reverse()) {
    if (message.content.includes("LUCK:")) {
      const match = message.content.match(/LUCK:\s*(\d+)/);
      if (match) {
        luckValue = Number(match[1]);
        break;
      }
    }
  }

  if (luckValue !== null) {
    const selectedToken = canvas.tokens.controlled[0];
    if (!selectedToken) {
      ui.notifications.warn("Please select a token.");
      return;
    }
    const actor = selectedToken.actor;
    const currentLuck = actor.system.stats.luck.value;
    const newLuck = Math.max(currentLuck - luckValue, 0);

    await actor.update({ "system.stats.luck.value": newLuck });

    ChatMessage.create({
      content: `The Luck value of ${luckValue} was deducted. Remaining Luck: ${newLuck} (by ${game.user.name})`,
      speaker: ChatMessage.getSpeaker()
    });
  } else {
    ui.notifications.warn("No Luck value found in recent chat messages.");
  }
}

// Variables to store token data
let currentHP, maxHP, tokenName;
let currentArmorBodyValue, maxArmorBodyValue, currentArmorHeadValue, maxArmorHeadValue;
let currentArmorShieldValue, maxArmorShieldValue;
let movWalk, movRun, currentLuck, maxLuck;

// Function to update token data
function updateTokenData() {
  const selectedToken = canvas.tokens.controlled[0];
  if (!selectedToken) {
    ui.notifications.warn("Please select a token.");
    return;
  }
  const actor = selectedToken.actor;
  currentHP = actor.system.derivedStats.hp.value;
  maxHP = actor.system.derivedStats.hp.max;
  tokenName = selectedToken.name;
  movWalk = actor.system.derivedStats.walk.value;
  movRun = actor.system.derivedStats.run.value;
  currentLuck = actor.system.stats.luck.value;
  maxLuck = actor.system.stats.luck.max;
  bodyValue = selectedToken.actor.system.stats.body.value;
  willValue = selectedToken.actor.system.stats.will.value;

  // Retrieve armor values
  currentArmorBodyValue = actor.system.externalData?.currentArmorBody?.value || 0;
  maxArmorBodyValue = actor.system.externalData?.currentArmorBody?.max || 0;
  currentArmorHeadValue = actor.system.externalData?.currentArmorHead?.value || 0;
  maxArmorHeadValue = actor.system.externalData?.currentArmorHead?.max || 0;
  currentArmorShieldValue = actor.system.externalData?.currentArmorShield?.value || 0;
  maxArmorShieldValue = actor.system.externalData?.currentArmorShield?.max || 0;
}

// Update data for initial use
updateTokenData();

// Retrieve selected token and weapons
const selectedToken = canvas.tokens.controlled[0];
if (!selectedToken) {
  ui.notifications.warn("Please select a token.");
  return;
}

const weapons = selectedToken.actor.items.filter(item => item.type === "weapon");
const cyberwareWeapons = selectedToken.actor.items.filter(item => item.type === "cyberware" && item.system.isWeapon);
const weaponUpgrades = selectedToken.actor.items.filter(item => 
  item.type === "itemUpgrade" && 
  item.system.weaponType && 
  item.system.installedIn
);
const allWeapons = [...weapons, ...cyberwareWeapons, ...weaponUpgrades];

// Pre-select weapon logic
const equippedWeapon = allWeapons.find(weapon => weapon.system.equipped === "equipped");
const carriedWeapon = allWeapons.find(weapon => weapon.system.equipped === "carried");
const selectedWeapon = equippedWeapon || carriedWeapon || allWeapons[0];

const reflexValue = selectedToken.actor.system.stats.ref.value;
const dexValue = selectedToken.actor.system.stats.dex.value;
const evasionSkillLevel = selectedToken.actor.items.find(item => item.name === "Evasion")?.system.level || 0;
const evasionValue = dexValue + evasionSkillLevel;

const updateHPDisplay = () => {
  const hpColor = currentHP === maxHP ? 'green' : (currentHP < (maxHP / 2) ? 'red' : '');
  document.getElementById('token-hp').innerHTML = `Hitpoints: <span style="color: ${hpColor};">${currentHP}</span>/${maxHP}`;
  selectedToken.refreshHUD();
};

// Function to generate weapon content with damage override check
async function generateWeaponContent() {
  const weaponContent = await Promise.all(allWeapons.map(async (weapon) => {
    let damageDisplay = weapon.system.damage || "-";

    // Check if weapon has loaded ammo with override damage
    const ammoData = weapon.system.magazine?.ammoData;
    if (ammoData && ammoData.uuid) {
      const ammoItem = await fromUuid(ammoData.uuid);
      const damageOverride = ammoItem?.system.overrides?.damage;

      // Use override damage if "Modify Damage" is not set to "No"
      if (damageOverride && damageOverride.mode !== "none" && damageOverride.value) {
        damageDisplay = damageOverride.value;
      }
    }

    const ammoType = weapon.system.magazine?.ammoData?.name || "No Ammo Loaded";

    return `
      <div class="weapon-item" style="display: flex; justify-content: space-between; align-items: center; padding: 5px; border-bottom: 1px solid #ccc;">
        <div style="display: flex; align-items: center;">
          <img src="${weapon.img}" alt="${weapon.name}" style="width: 24px; height: 24px; margin-right: 10px;">
          <label>
            <input type="radio" name="weapon" value="${weapon.id}" ${weapon.id === selectedWeapon.id ? 'checked' : ''}>
            ${weapon.name}
          </label>
        </div>
        <div style="text-align: right; font-size: 0.9em; color: #555;">
          <span class="text-pill text-italic " data-tooltip="${ammoType}">
            ${(weapon.system.magazine && (weapon.system.magazine.value > 0 || weapon.system.magazine.max > 0)) 
              ? `${weapon.system.magazine.value}/${weapon.system.magazine.max}` 
              : "-"}
          </span>
          <span class="text-pill text-italic" data-tooltip="Rate of Fire">
            ROF ${weapon.system.rof || "-"}
          </span>
          <span class="text-pill text-italic" data-tooltip="Damage per Shot">
            ${damageDisplay}
          </span>
        </div>
      </div>
    `;
  }));
  return weaponContent.join('');
}

// Generate weapon content and render the dialog
generateWeaponContent().then(weaponContent => {
  new Dialog({
    title: "Little Combat Tool",
    content: `
      <form>
        <!-- Top Frame -->
        <fieldset style="border: 1px solid #ccc; padding: 10px; margin-bottom: 10px;">
          <legend><strong>${tokenName}</strong></legend>
          <div style="display: flex; justify-content: space-between;">
            <div id="reflex-display" style="font-weight: bold;" data-tooltip="Reflex 8 or higher: you're able to dodge bullets and explosions">
              Reflex: <span style="color: ${reflexValue >= 8 ? 'green' : ''};">${reflexValue}</span><br>
              Speed: ${actor.system.stats.move.value} / ${movRun/2}<br>
              Speedheal: <span style="color: ${(bodyValue + willValue) < (maxHP - currentHP) ? 'red' : ((currentHP < maxHP && (bodyValue + willValue) >= (maxHP - currentHP)) ? 'green' : '')};">${bodyValue + willValue}</span><br>
              Luck: <span style="color: ${currentLuck === maxLuck ? 'green' : (currentLuck < maxLuck / 2 ? 'red' : '')};">${currentLuck}</span> / ${maxLuck}
              
            </div>
            <div id="additional-info" style="text-align: left; padding-left: 10px;">
              <small>Evasion: ${evasionValue}</small><br>
              <small>${movWalk}m / ${movRun}m</small><br>
              <small>BODY: ${bodyValue}, WILL: ${willValue}</small>
          </div>
            <div id="token-stats" style="font-weight: bold; text-align: right;">
              Hitpoints: <span style="color: ${currentHP === maxHP ? 'green' : (currentHP < maxHP / 2 ? 'red' : '')};">${currentHP}</span> / ${maxHP}<br>
              Body Armor: <span style="color: ${currentArmorBodyValue === maxArmorBodyValue ? 'green' : (currentArmorBodyValue < maxArmorBodyValue / 2 ? 'red' : '')};">${currentArmorBodyValue}</span> / ${maxArmorBodyValue}<br>
              Head Armor: <span style="color: ${currentArmorHeadValue === maxArmorHeadValue ? 'green' : (currentArmorHeadValue < maxArmorHeadValue / 2 ? 'red' : '')};">${currentArmorHeadValue}</span> / ${maxArmorHeadValue}<br>
              ${maxArmorShieldValue > 0 ? `Shield Armor: <span style="color: ${currentArmorShieldValue === maxArmorShieldValue ? 'green' : (currentArmorShieldValue < maxArmorShieldValue / 2 ? 'red' : '')};">${currentArmorShieldValue}</span> / ${maxArmorShieldValue}` : ""}
            </div>
          </div>
        </fieldset>

        <!-- Middle Frame -->
        <fieldset style="border: 1px solid #ccc; padding: 10px; margin-bottom: 10px;">
          <legend><strong>Manage Weapons</strong></legend>
          <div class="weapon-list" style="max-height: 160px; overflow-y: auto;">
            ${weaponContent}
          </div>
          <br>
          <div class="buttons-container" style="display: flex; justify-content: space-between;">
            <div class="location-buttons" style="display: flex; flex-direction: column; align-items: center;">
              <button type="button" id="set-all-owned-btn" style="width: 100px;">Set all owned</button>
              <button type="button" id="owned-btn" style="width: 100px;">
               <i class="fas fa-circle-notch"></i> Owned
              </button>
              <button type="button" id="carried-btn" style="width: 100px;">
                <i class="fas fa-suitcase"></i> Carried
              </button>
              <button type="button" id="equipped-btn" style="width: 100px;">
                <i class="fas fa-hand-paper"></i> Equipped
              </button>
            </div>
            <div class="mid-button" style="align-self: center; margin: 0 1px; display: flex; flex-direction: column; align-items: center;">
              <button type="button" id="open-gear-btn" style="width: 100px;">Open Gear</button>
              <button type="button" id="deduct-luck-btn" style="width: 100px;">Deduct Luck</button>
              <button type="button" id="no-targets" style="width: 100px;" title="Remove Target from all Tokens">
              Remove <i class="fas fa-bullseye"></i> 
              </button>
              <button type="button" id="delete-templates" style="width: 100px;" title="Remove all Measaurement Templates on Scene">
                Remove <i class="fas fa-ruler-combined"></i> 
              </button>
            </div>
            <div class="attack-buttons" style="display: flex; flex-direction: column; align-items: center;">
              <button type="button" id="attack-btn" style="width: 100px;" data-roll-type="attack">Attack</button>
              <button type="button" id="aimed-btn" style="width: 100px;" data-roll-type="aimed">Aimed</button>
              <button type="button" id="autofire-btn" style="width: 100px;" data-roll-type="autofire">Autofire</button>
              <button type="button" id="suppressive-btn" style="width: 100px;" data-roll-type="suppressive">Suppressive</button>
            </div>
          </div>
        </fieldset>

        <!-- Bottom Frame -->
        <fieldset style="border: 1px solid #ccc; padding: 10px;">
          <legend><strong>Defense and Damage</strong></legend>
          <div class="form-group" style="display: flex; justify-content: center; margin-bottom: 10px;">
            <button type="button" id="evasion-btn" style="width: 150px;" title="Select Defender Token">Evasion</button>
          </div>
          <div class="form-group" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <button type="button" id="resist-torture-btn" style="width: 175px;" title="Select Defender Token">Resist Torture / Drugs</button>
            <button type="button" id="concentration-btn" style="width: 175px;" title="Select Defender Token">Concentration</button>
          </div>
          <div class="form-group" style="display: flex; justify-content: center; align-items: center; font-weight: bold; margin-bottom: 10px;">
            <div style="margin-right: 10px;">Modify Hitpoints</div>
            <button type="button" id="add-hp-btn" style="width: 80px;"><i class="fas fa-plus"></i></button>
            <input type="number" id="hp-modify" name="hp-modify" placeholder="HP" style="width: 60px; margin: 0 10px;">
            <button type="button" id="subtract-hp-btn" style="width: 80px;"><i class="fas fa-minus"></i></button>
          </div>
          <!-- Custom Damage Roll -->
          <div class="form-group" style="display: flex; justify-content: center; align-items: center; font-weight: bold; margin-bottom: 10px;">
            <label for="custom-damage" style="margin-right: 10px;">Roll Damage</label>
            <input type="number" id="custom-damage" name="custom-damage" placeholder="Number of D6" style="width: 60px; margin-right: 10px;">
            <button type="button" id="custom-damage-roll-btn" style="width: 60px;">Roll</button>
          </div>
        </fieldset>
      </form>
      <style>
        .location-buttons button,
        .attack-buttons button,
        .mid-button button {
          margin: 2px 0;
          text-align: center;
        }
        .location-buttons button.active,
        .attack-buttons button.active,
        .mid-button button.active {
          font-weight: bold;
          background-color: #007bff;
          color: white;
        }
        .location-buttons button:disabled {
          background-color: #ccc;
          color: #666;
          cursor: not-allowed;
        }
      </style>
    `,
    buttons: {},
    default: "equipped",
    render: (html) => {
      const updateButtonStyles = (weapon) => {
        const equippedStatus = weapon?.system?.equipped;
        html.find('.location-buttons button').removeClass('active');
        if (equippedStatus) {
          html.find(`#${equippedStatus}-btn`).addClass('active');
        }
      };

      const setSelectedWeapon = () => {
        const selectedWeaponId = html.find('input[name="weapon"]:checked').val();
        const selectedWeapon = allWeapons.find(weapon => weapon.id === selectedWeaponId);
        updateButtonStyles(selectedWeapon);

        const isCyberwareOrUpgrade = cyberwareWeapons.some(cyberware => cyberware.id === selectedWeaponId) ||
                                     weaponUpgrades.some(upgrade => upgrade.id === selectedWeaponId);

        if (isCyberwareOrUpgrade) {
          html.find('.location-buttons button').attr('disabled', true);
        } else {
          html.find('.location-buttons button').attr('disabled', false);
        }
      };

      html.find('input[name="weapon"]').on('change', setSelectedWeapon);
      setSelectedWeapon(); // Initial selection

      html.find('#deduct-luck-btn').on('click', () => findAndDeductLuck());
      html.find('#set-all-owned-btn').on('click', async () => {
        for (const weapon of allWeapons) {
          await weapon.update({ "system.equipped": "owned" });
        }
        html.find('.location-buttons button').removeClass('active');
        html.find('#owned-btn').addClass('active');
      });

      const updateWeaponStatus = async (status) => {
        const selectedWeaponId = html.find('input[name="weapon"]:checked').val();
        const selectedWeapon = allWeapons.find(weapon => weapon.id === selectedWeaponId);
        if (selectedWeapon) {
          await selectedWeapon.update({ "system.equipped": status });
          updateButtonStyles(selectedWeapon);
        }
      };

      html.find('#owned-btn').on('click', () => updateWeaponStatus("owned"));
      html.find('#carried-btn').on('click', () => updateWeaponStatus("carried"));
      html.find('#equipped-btn').on('click', () => updateWeaponStatus("equipped"));

      html.find('#open-gear-btn').on('click', () => {
        selectedToken.actor.sheet.render(true);
        selectedToken.actor.sheet.activateTab("gear");
      });

      const rollWeapon = async (rollType) => {
        const selectedWeaponId = html.find('input[name="weapon"]:checked').val();
        if (selectedWeaponId) {
          const weapon = allWeapons.find(w => w.id === selectedWeaponId);
          if (weapon) {
            const skipPrompt = false;
            await game.cpr.macro.rollItemMacro(weapon.name, { skipPrompt, rollType });
          }
        }
      };

      html.find('#attack-btn').on('click', () => {
        selectedToken.control();
        rollWeapon("attack");
      });

      html.find('#aimed-btn').on('click', () => {
        selectedToken.control();
        rollWeapon("aimed");
      });

      html.find('#autofire-btn').on('click', () => {
        selectedToken.control();
        rollWeapon("autofire");
      });

      html.find('#suppressive-btn').on('click', () => {
        selectedToken.control();
        rollWeapon("suppressive");
      });

      html.find('#evasion-btn').on('click', async () => {
        const selectedToken = canvas.tokens.controlled[0];
        const reflexValue = selectedToken.actor.system.stats.ref.value;

        if (reflexValue < 8) {
          new Dialog({
            title: "Low Reflex Warning",
            content: `<p>REF is less than 8. <strong>${selectedToken.name}</strong> can only dodge melee attacks.</p>`,
            buttons: {
              ok: {
                label: "OK",
                callback: async () => {
                  const skipPrompt = false;
                  await game.cpr.macro.rollItemMacro("Evasion", { skipPrompt });
                }
              },
              cancel: {
                label: "Cancel",
                callback: () => {} 
              }
            },
            default: "ok"
          }).render(true);
        } else {
          const skipPrompt = false;
          await game.cpr.macro.rollItemMacro("Evasion", { skipPrompt });
        }
      });

      const modifyHP = async (modifier) => {
        const value = parseInt(html.find('#hp-modify').val());
        if (!isNaN(value) && value > 0) {
          const selectedToken = canvas.tokens.controlled[0];
          const maxHP = selectedToken.actor.system.derivedStats.hp.max;
          let currentHP = selectedToken.actor.system.derivedStats.hp.value;

          currentHP = modifier === "add"
            ? Math.min(currentHP + value, maxHP)
            : Math.max(currentHP - value, 0);

          await selectedToken.actor.update({ "system.derivedStats.hp.value": currentHP });
          ChatMessage.create({
            content: `<strong>${selectedToken.name}</strong> ${modifier === "add" ? "gains" : "loses"} <strong>${value}</strong> hitpoints. (by ${game.user.name})`,
            speaker: ChatMessage.getSpeaker()
          });
          updateHPDisplay();
        } else {
          ui.notifications.warn("Please enter a positive number.");
        }
      };

      html.find('#add-hp-btn').on('click', () => modifyHP("add"));
      html.find('#subtract-hp-btn').on('click', () => modifyHP("subtract"));

      html.find('#resist-torture-btn').on('click', async () => {
        const skipPrompt = false;
        await game.cpr.macro.rollItemMacro("Resist Torture/Drugs", { skipPrompt });
      });

      html.find('#concentration-btn').on('click', async () => {
        const skipPrompt = false;
        await game.cpr.macro.rollItemMacro("Concentration", { skipPrompt });
      });

      html.find('#no-targets').on('click', () => {
        game.user.targets.forEach(token => token.setTarget(false));
        ui.notifications.info("All targets have been removed.");
      });

      html.find('#custom-damage-roll-btn').on('click', async () => {
        const numDice = parseInt(html.find('#custom-damage').val());
        if (!isNaN(numDice) && numDice > 0) {
          const chatCommand = `/red ${numDice}d6`;
          ui.chat.processMessage(chatCommand);
        } else {
          ui.notifications.warn("Please enter a valid number of D6.");
        }
      });
      // Function to delete all template measurements
      function deleteAllTemplates() {
        const templates = canvas.templates.placeables;
        if (templates.length > 0) {
          canvas.scene.deleteEmbeddedDocuments("MeasuredTemplate", templates.map(t => t.id));
          ui.notifications.info("All template measurements have been deleted.");
        } else {
          ui.notifications.warn("No templates found to delete.");
        }
      }

      // Event listener for the "Del. Templ." button
      html.find('#delete-templates').on('click', () => deleteAllTemplates());

    }
  }).render(true);
});