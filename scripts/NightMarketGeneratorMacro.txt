// Define keywords for searching in the compendiums
const keywords = ["armor", "gear", "weapons", "cyberware"];

// Filter all compendiums based on the keywords
const compendiumList = game.packs.filter(pack => 
    keywords.some(keyword => pack.metadata.id.toLowerCase().includes(keyword))
);

// Check if the Actor "Night Market" exists, create if it doesn't
let actor = game.actors.getName("Night Market") || await Actor.create({
    name: "Night Market",
    type: "container",
    img: "systems/cyberpunk-red-core/icons/compendium/default/Default_Container.svg",
    folder: game.folders.getName("Containers & Vendors")?._id,
});

// Notify chat
ChatMessage.create({ content: `Your Fixer located a "<strong>${actor.name}</strong>" nearby.`, type: CONST.CHAT_MESSAGE_TYPES.OTHER });

// Roll a D10 to determine how many items to select for each category
const rollD10 = () => Math.floor(Math.random() * 10) + 1;
const itemCounts = { armor: rollD10(), gear: rollD10(), weapons: rollD10(), cyberware: rollD10() };

// Function to select random items, alternating between compendiums and avoiding duplicates
async function selectItemsByCategory(compendiums, itemCounts) {
    const selectedItems = { armor: [], gear: [], weapons: [], cyberware: [] };

    for (const category in itemCounts) {
        const categoryCompendiums = compendiums.filter(comp => comp.metadata.id.toLowerCase().includes(category));
        let totalSelectedItems = 0, compendiumIndex = 0;
        const usedItemIds = new Set();  // Track item IDs to avoid duplicates

        while (totalSelectedItems < itemCounts[category]) {
            const compendium = categoryCompendiums[compendiumIndex];
            const items = (await compendium.getDocuments()).filter(item => 
                item.system?.price?.market > 1 && 
                item.system?.price?.market < 1001 && 
                item.system?.source?.book !== "ELO" &&
                !usedItemIds.has(item.id)  // Avoid duplicates
            ).sort(() => Math.random() - 0.5);

            if (items.length > 0) {
                const selectedItem = items[0];
                selectedItems[category].push(selectedItem);
                usedItemIds.add(selectedItem.id);  // Add to the used set to prevent duplicates
                totalSelectedItems++;
            }

            compendiumIndex = (compendiumIndex + 1) % categoryCompendiums.length;
        }
    }

    return selectedItems;
}

// Select and add items to the Actor
const selectedItems = await selectItemsByCategory(compendiumList, itemCounts);
for (const category in selectedItems) {
    for (const item of selectedItems[category]) {
        await actor.createEmbeddedDocuments("Item", [duplicate(item)]);
    }
}